#tag ClassProtected Class gdImage	#tag Method, Flags = &h0		Function Alpha(colour As Integer) As Integer		  Declare Function gdImageAlpha Lib libgd _		  (im As Ptr, colour As Integer) As Integer		  		  Return gdImageAlpha(Pointer, colour)		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub AlphaBlending(blending As Integer)		  Declare Sub gdImageAlphaBlending Lib libgd _		  (im As Ptr, blending As Integer)		  		  Call gdImageAlphaBlending(Pointer, blending)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Arc(cx As Integer, cy As Integer, w As Integer, h As Integer, s As Integer, e As Integer, colour As Integer)		  Declare Sub gdImageArc Lib libgd _		  (im As Ptr, cx As Integer, cy As Integer, w As Integer, h As Integer, s As Integer, e As Integer, colour As Integer)		  		  Call gdImageArc(Pointer, cx, cy, w, h, s, e, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Blue(x As Integer, y As Integer) As Integer		  Declare Function gdImageBlue Lib libgd (im As Ptr, cl As Integer) As Integer		  Dim cl As Integer		  		  cl=GetPixel(x,y)		  		  Return gdImageBlue(Pointer, cl)		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function BoundsSafe(x As Integer, y As Integer) As Boolean		  Declare Function gdImageBoundsSafe Lib libgd _		  (im As Ptr, x As Integer, y As Integer) As Integer		  		  Return (gdImageBoundsSafe(Pointer, x, y) = 1)		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Char(FontRef As MemoryBlock, x As Integer, y As Integer, charAsInt As Integer, colour As Integer)		  Declare Sub gdImageChar Lib libgd _		  (im As Ptr, FontRef As Ptr, x As Integer, y As Integer, charAsInt As Integer, colour As Integer)		  		  Call gdImageChar(Pointer, FontRef, x, y, charAsInt, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Char(FontRef As MemoryBlock, x As Integer, y As Integer, charAsStr As String, colour As Integer)		  Declare Sub gdImageChar Lib libgd _		  (im As Ptr, FontRef As Ptr, x As Integer, y As Integer, charAsInt As Integer, colour As Integer)		  		  Call gdImageChar(Pointer, FontRef, x, y, AscB(charAsStr.LeftB(1)), colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub CharUp(FontRef As MemoryBlock, x As Integer, y As Integer, charAsInt As Integer, colour As Integer)		  Declare Sub gdImageCharUp Lib libgd _		  (im As Ptr, FontRef As Ptr, x As Integer, y As Integer, charAsInt As Integer, colour As Integer)		  		  Call gdImageCharUp(Pointer, FontRef, x, y, charAsInt, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub CharUp(FontRef As MemoryBlock, x As Integer, y As Integer, charAsStr As String, colour As Integer)		  Declare Sub gdImageCharUp Lib libgd _		  (im As Ptr, FontRef As Ptr, x As Integer, y As Integer, charAsInt As Integer, colour As Integer)		  		  Call gdImageCharUp(Pointer, FontRef, x, y, AscB(charAsStr.LeftB(1)), colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ColorAllocate(red As Integer, green As Integer, blue As Integer) As Integer		  Declare Function gdImageColorAllocate Lib libgd _		  (im As Ptr, red As Integer, green As Integer, blue As Integer) As Integer		  		  Return gdImageColorAllocate(Pointer, red, green, blue)		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ColorResolve(red As Integer, green As Integer, blue As Integer) As Integer		  Declare Function gdImageColorResolve Lib libgd _		  (im As Ptr, red As Integer, green As Integer, blue As Integer) As Integer		  		  Return gdImageColorResolve(Pointer, red, green, blue)		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ColorResolveAlpha(red As Integer, green As Integer, blue As Integer, alpha As Integer) As Integer		  Declare Function gdImageColorResolveAlpha Lib libgd _		  (im As Ptr, red As Integer, green As Integer, blue As Integer, alpha As Integer) As Integer		  		  Return gdImageColorResolveAlpha(Pointer, red, green, blue, alpha)		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(w As Integer, h As Integer)		  'gdImageCreate is called to create palette-based images,		  'with no more than 256 colors. Invoke gdImageCreate with		  'the x and y dimensions of the desired image.		  'gdImageCreate returns a gdImagePtr to the new image,		  'or NULL if unable to allocate the image.		  'The image must eventually be destroyed using gdImageDestroy().		  		  Declare Function gdImageCreate Lib libgd _		  (w As Integer, h As Integer) As Ptr		  		  LastError=0		  		  Pointer=New MemoryBlock(4)		  Pointer=gdImageCreate(w, h)		  		  if Pointer=Nil Then LastError=kPointerInvalid		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(w As Integer, h As Integer, tc As Boolean)		  'gdImageCreateTrueColor is called to create truecolor images,		  'with an essentially unlimited number of colors.		  'Invoke gdImageCreateTrueColor with the x and y dimensions		  'of the desired image. gdImageCreateTrueColor returns a gdImagePtr		  'to the new image, or NULL if unable to allocate the image.		  'The image must eventually be destroyed using gdImageDestroy().		  		  		  'Pointer=New MemoryBlock(4)		  LastError=0		  		  if tc Then		    Declare Function gdImageCreateTrueColor Lib libgd _		    (sx As Integer, sy As Integer) As Ptr		    Pointer=gdImageCreateTrueColor(w, h)		  Else		    Declare Function gdImageCreate Lib libgd _		    (sx As Integer, sy As Integer) As Ptr		    Pointer=gdImageCreate(w, h)		  End If		  		  If Pointer=Nil Then LastError=kPointerInvalid		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(fp As String, Type As Integer)		  LastError=0		  		  Select Case Type		  Case kJpegImage		    print "Jpeg file"		    OpenJpeg(fp)		    		  Case kPngImage		    OpenPng(fp)		    		  Case kGifImage		    OpenGif(fp)		    		  Case kWbmpImage		    OpenWbmp(fp)		    		  Case kGd2Image		    OpenGd2(fp)		    		  Case kTiffImage		    OpenTiff(fp)		    		  End Select		  		  // Cache width/height		  if Pointer<>Nil Then		    if TrueColor() Then		      Print "TrueColor = True"		    else		      Print "TrueColor = False"		    end if		  end if		  		  FilePath=fp		  if Pointer=Nil Then LastError=kPointerInvalid		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Copy(src As gdImage, destX As Integer, destY As Integer, srcX As Integer, srcY As Integer, w As Integer, h As Integer)		  Declare Sub gdImageCopy Lib libgd _		  (dst As Ptr, src As Ptr, destX As Integer, destY As Integer, _		  srcX As Integer, srcY As Integer, w As Integer,h As Integer)		  		  Call gdImageCopy(Pointer, src.Pointer, destX, destY, srcX, srcY, w, h)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub CopyMerge(src As gdImage, destX As Integer, destY As Integer, srcX As Integer, srcY As Integer, w As Integer, h As Integer, pct As Integer)		  Declare Sub gdImageCopyMerge Lib libgd _		  (dst As Ptr, src As Ptr, destX As Integer, destY As Integer, _		  srcX As Integer, srcY As Integer, w As Integer,h As Integer, pct As Integer)		  		  Call gdImageCopyMerge(Pointer, src.Pointer, destX, destY, srcX, srcY, w, h, pct)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub CopyResampled(src As gdImage, destX As Integer, destY As Integer, srcX As Integer, srcY As Integer, destW As Integer, destH As Integer, srcW As Integer, srcH As Integer)		  Declare Sub gdImageCopyResampled Lib libgd _		  (dst As Ptr, src As Ptr, destX As Integer, destY As Integer, _		  srcX As Integer, srcY As Integer, destW As Integer, _		  destH As Integer, srcW As Integer, srcH As Integer)		  		  Call gdImageCopyResampled(Pointer, src.Pointer, destX, destY, srcX, srcY, destW, destH, srcW, srcH)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub CopyResized(src As gdImage, destX As Integer, destY As Integer, srcX As Integer, srcY As Integer, destW As Integer, destH As Integer, srcW As Integer, srcH As Integer)		  Declare Sub gdImageCopyResized Lib libgd _		  (dst As Ptr, src As Ptr, destX As Integer, destY As Integer, _		  srcX As Integer, srcY As Integer, destW As Integer, _		  destH As Integer, srcW As Integer, srcH As Integer)		  		  Call gdImageCopyResized(Pointer, src.Pointer, destX, destY, srcX, srcY, destW, destH, srcW, srcH)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub CopyRotated(src As gdImage, destX As Integer, destY As Integer, srcX As Integer, srcY As Integer, w As Integer, h As Integer, Angle As Integer)		  Declare Sub gdImageCopyRotated Lib libgd _		  (dst As Ptr, src As Ptr, destX As Integer, destY As Integer, _		  srcX As Integer, srcY As Integer, w As Integer,h As Integer, Angle As Integer)		  		  Call gdImageCopyRotated(Pointer, src.Pointer, destX, destY, srcX, srcY, w, h, Angle)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub DashedLine(x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, colour As Integer)		  Declare Sub gdImageDashedLine Lib libgd _		  (im As Ptr, x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, colour As Integer)		  		  Call gdImageDashedLine(Pointer, x1, y1, x2, y2, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Destructor()		  Declare Sub gdImageDestroy Lib libgd (im As Ptr)		  		  if Pointer<>Nil Then		    Print "Good bye..."		    Call gdImageDestroy(Pointer)		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub DrawString(FontRef As MemoryBlock, x As Integer, y As Integer, MyString As String, colour As Integer)		  Declare Sub gdImageString Lib libgd _		  (im As Ptr, FontRef As Ptr, x As Integer, y As Integer, MyString As Ptr, colour As Integer)		  Dim theString As MemoryBlock		  theString=MyString		  		  Call gdImageString(Pointer, FontRef, x, y, theString, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub DrawStringFT(s As String, colour As Integer, FontPath As String, size As Double, Angle As Double, x As Integer, y As Integer)		  Declare Function gdImageStringFT Lib libgd _		  (im As Ptr, brect As Ptr, colour As Integer, _		  FontPath As Ptr, size As Double, Angle As Double, x As Integer, y As Integer, stringtoprint As Ptr) _		  As Ptr		  		  Dim brect, err, strng, fpth As MemoryBlock		  brect=New MemoryBlock(8*4)		  strng=s+ChrB(0)		  fpth=FontPath+ChrB(0)		  		  err = gdImageStringFT(Pointer, brect, colour, fpth, size, Angle, x, y, strng)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function DrawStringFT(s As String, colour As Integer, FontPath As String, size As Double, Angle As Double, x As Integer, y As Integer) As MemoryBlock		  Declare Function gdImageStringFT Lib libgd _		  (im As Ptr, brect As Ptr, colour As Integer, _		  FontPath As Ptr, size As Double, Angle As Double, x As Integer, y As Integer, stringtoprint As Ptr) _		  As Ptr		  		  Dim brect, err, strng, fpth As MemoryBlock		  brect=New MemoryBlock(8*4)		  strng=s		  fpth=FontPath		  		  err = gdImageStringFT(Pointer, brect, colour, fpth, size, Angle, x, y, strng)		  // return brect		  Return brect		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub DrawStringFTCircle(cx As Integer, cy As Integer, radius As Double, textRadius As Double, fillPortion As Double, FontPath As String, points As Double, TopString As String, BottomString As String, colour As Integer)		  Declare Function gdImageStringFT Lib libgd _		  (im As Ptr, cx As Integer, cy As Integer, _		  radius As Double, textRadius As Double, fillPortion As Double, _		  font As Ptr, points As Double, TopString As Ptr, BottomString As Ptr, colour As Integer) _		  As Ptr		  		  Dim brect, err, topStr, btmStr, fpth As MemoryBlock		  brect=New MemoryBlock(8*4)		  topStr=TopString		  btmStr=BottomString		  fpth=FontPath		  		  err = gdImageStringFT(Pointer, cx, cy, radius, textRadius, _		  fillPortion, fpth, points, topStr, btmStr, colour)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ErrorCode() As Integer		  Return LastError		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Fill(x As Integer, y As Integer, colour As Integer)		  Declare Sub gdImageFill Lib libgd _		  (im As Ptr, x As Integer, y As Integer, colour As Integer)		  		  Call gdImageFill(Pointer, x, y, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub FilledArc(cx As Integer, cy As Integer, w As Integer, h As Integer, s As Integer, e As Integer, colour As Integer)		  Declare Sub gdImageFilledArc Lib libgd _		  (im As Ptr, cx As Integer, cy As Integer, w As Integer, h As Integer, _		  s As Integer, e As Integer, colour As Integer)		  		  Call gdImageFilledArc(Pointer, cx, cy, w, h, s, e, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub FilledArc(cx As Integer, cy As Integer, w As Integer, h As Integer, s As Integer, e As Integer, colour As Integer, Type As Integer)		  Declare Sub gdImageFilledArc Lib libgd _		  (im As Ptr, cx As Integer, cy As Integer, w As Integer, h As Integer, _		  s As Integer, e As Integer, colour As Integer, Type As Integer)		  		  Call gdImageFilledArc(Pointer, cx, cy, w, h, s, e, colour, Type)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub FilledEllipse(cx As Integer, cy As Integer, w As Integer, h As Integer, colour As Integer)		  Declare Sub gdImageFilledEllipse Lib libgd _		  (im As Ptr, cx As Integer, cy As Integer, w As Integer, h As Integer, colour As Integer)		  		  Call gdImageFilledEllipse(Pointer, cx, cy, w, h, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub FilledPolygon(Points() As Integer, colour As Integer)		  Declare Sub gdImageFilledPolygon Lib libgd _		  (im As Ptr, gdPointPtr As Ptr, numPoints As Integer, colour As Integer)		  		  Dim gdPoints As MemoryBlock		  Dim i,j,n As Integer		  		  j=UBound(Points)		  n=(j+1)*4		  gdPoints=New MemoryBlock(n)		  for i=0 to j		    gdPoints.Long(i*4)=Points(i)		  next		  n=(j+1)/2		  		  Call gdImageFilledPolygon(Pointer, gdPoints, n, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub FilledRectangle(x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, colour As Integer)		  Declare Sub gdImageFilledRectangle Lib libgd _		  (im As Ptr, x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, colour As Integer)		  		  Dim xx1, xx2, yy1, yy2 As Integer		  		  if x1>x2 Then		    xx1=x2		    xx2=x1		  else		    xx1=x1		    xx2=x2		  end if		  if y1>y2 Then		    yy1=y2		    yy2=y1		  else		    yy1=y1		    yy2=y2		  end if		  		  Call gdImageFilledRectangle(Pointer, xx1, yy1, xx2, yy2, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub FillToBorder(x As Integer, y As Integer, border As Integer, colour As Integer)		  Declare Sub gdImageFillToBorder Lib libgd _		  (im As Ptr, x As Integer, y As Integer, border As Integer, colour As Integer)		  		  Call gdImageFillToBorder(Pointer, x, y, border, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub GetClip(ByRef x1 As Integer, ByRef y1 As Integer, ByRef x2 As Integer, ByRef y2 As Integer)		  Declare Sub gdImageGetClip Lib libgd _		  (im As Ptr, ByRef x1 As Integer, ByRef y1 As Integer, _		  ByRef x2 As Integer, ByRef y2 As Integer)		  		  Call gdImageGetClip(Pointer, x1, y1, x2, y2)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function GetGiantFont() As MemoryBlock		  Declare Function gdFontGetGiant Lib libgd () As Ptr		  		  Return gdFontGetGiant()		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetLargeFont() As MemoryBlock		  Declare Function gdFontGetLarge Lib libgd () As Ptr		  		  Return gdFontGetLarge()		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetMediumBoldFont() As MemoryBlock		  Declare Function gdFontGetMediumBold Lib libgd () As Ptr		  		  Return gdFontGetMediumBold()		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetPixel(x As Integer, y As Integer) As Integer		  Declare Function gdImageGetPixel Lib libgd _		  (im As Ptr, x As Integer, y As Integer) As Integer		  		  Return gdImageGetPixel(Pointer, x, y)		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetSmallFont() As MemoryBlock		  Declare Function gdFontGetSmall Lib libgd () As Ptr		  		  Return gdFontGetSmall()		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetTinyFont() As MemoryBlock		  Declare Function gdFontGetTiny Lib libgd () As Ptr		  		  Return gdFontGetTiny()		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Green(x As Integer, y As Integer) As Integer		  Declare Function gdImageGreen Lib libgd (im As Ptr, cl As Integer) As Integer		  Dim cl As Integer		  		  cl=GetPixel(x,y)		  		  Return gdImageGreen(Pointer, cl)		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Height() As Integer		  Return SY()		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Line(x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, colour As Integer)		  Declare Sub gdImageLine Lib libgd _		  (im As Ptr, x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, colour As Integer)		  		  Call gdImageLine(Pointer, x1, y1, x2, y2, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub OpenGd2(FP As String)		  Declare Function gdImageCreateFromGd2Ptr Lib libgd (DataSize As Integer, Data As Ptr) As Ptr		  		  Dim size As Integer		  Dim Data As MemoryBlock		  Dim f As FolderItem		  Dim bs As BinaryStream		  		  f=GetFolderItem(FP, f.PathTypeShell)		  if not f.Exists Then Return		  		  bs=BinaryStream.Open(f, False)		  if bs=Nil Then Return		  		  size=bs.Length		  Print "Size = "+Format(size, "###,###")		  Data=bs.Read(size)		  bs=Nil		  		  Pointer=gdImageCreateFromGd2Ptr(size, Data)		  		  FilePath=FP		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub OpenGif(FP As String)		  Declare Function gdImageCreateFromGifPtr Lib libgd (DataSize As Integer, Data As Ptr) As Ptr		  		  Dim size As Integer		  Dim Data As MemoryBlock		  Dim f As FolderItem		  Dim bs As BinaryStream		  		  f=GetFolderItem(FP, f.PathTypeShell)		  if not f.Exists Then		    Print FP+" is nil"		    Return		  End if		  bs=BinaryStream.Open(f, False)		  if bs=Nil Then		    Print "bs/"+FP+" is nil!"		    Return		  end if		  		  size=bs.Length		  Data=bs.Read(size)		  bs=Nil		  		  Pointer=gdImageCreateFromGifPtr(size, Data)		  		  FilePath=FP		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub OpenJpeg(FP As String)		  Declare Function gdImageCreateFromJpegPtr Lib libgd (DataSize As Integer, Data As Ptr) As Ptr		  		  Dim size As Integer		  Dim Data As MemoryBlock		  Dim f As FolderItem		  Dim bs As BinaryStream		  		  f=GetFolderItem(FP, f.PathTypeShell)		  if not f.Exists Then Return		  		  bs=BinaryStream.Open(f, False)		  if bs=Nil Then Return		  		  size=bs.Length		  Print "Size = "+Format(size, "###,###")		  Data=bs.Read(size)		  bs=Nil		  		  Pointer=gdImageCreateFromJpegPtr(size, Data)		  		  FilePath=FP		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub OpenPng(FP As String)		  Declare Function gdImageCreateFromPngPtr Lib libgd (DataSize As Integer, Data As Ptr) As Ptr		  		  Dim size As Integer		  Dim Data As MemoryBlock		  Dim f As FolderItem		  Dim bs As BinaryStream		  		  f=GetFolderItem(FP, f.PathTypeShell)		  if not f.Exists Then		    Print FP+" is nil"		    Return		  End if		  bs=BinaryStream.Open(f, False)		  if bs=Nil Then		    Print "bs/"+FP+" is nil!"		    Return		  end if		  		  size=bs.Length		  Data=bs.Read(size)		  bs=Nil		  		  Pointer=gdImageCreateFromPngPtr(size, Data)		  		  FilePath=FP		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub OpenPolygon(Points() As Integer, colour As Integer)		  Declare Sub gdImageOpenPolygon Lib libgd _		  (im As Ptr, gdPointPtr As Ptr, numPoints As Integer, colour As Integer)		  		  Dim gdPoints As MemoryBlock		  Dim i,j,n As Integer		  		  j=UBound(Points)		  n=(j+1)*4		  gdPoints=New MemoryBlock(n)		  for i=0 to j		    gdPoints.Long(i*4)=Points(i)		  next		  n=(j+1)/2		  		  Call gdImageOpenPolygon(Pointer, gdPoints, n, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub OpenTiff(fp As String)		  // GD doesn't support TIFF. I do ;-)		  // requires libtiff, see the constant. Set to /usr/local/lib/libtiff.dylib by default. As it should be...		  		  Declare Sub TIFFGetField  Lib libtiff (Tif As Ptr, Tag As Integer, ByRef Result As Integer)		  Declare Function TIFFOpen Lib libtiff (fname As Ptr, Rights As Ptr) As Ptr		  Declare Sub TIFFReadScanline Lib libtiff _		  (Tif As Ptr, buffer As Ptr, row As Integer, sample As Integer)		  Declare Function TIFFScanlineSize Lib libtiff (Tif As Ptr) As Integer		  		  Declare Sub TIFFClose Lib libtiff (Tif As Ptr)		  Declare Function gdImageCreateTrueColor Lib libgd (sx As Integer, sy As Integer) As Ptr		  		  Dim size, w, h, nbytes, p, i, j, k, cl As Integer		  Dim r, g, b As Integer		  Dim Tif, rights, fname, raster As MemoryBlock		  		  // libtiff provides for an open function.		  // Just pass file path and rights. Nice.		  fname=fp		  rights="r"		  		  Tif=TIFFOpen(fname, rights)		  if Tif = Nil Then		    Print "Tif = Nil"		    Return		  end if		  		  // get the geometry		  TIFFGetField(Tif, TIFFTAG_IMAGEWIDTH,  w)		  TIFFGetField(Tif, TIFFTAG_IMAGELENGTH, h)		  		  // Create a gd Image – that's the point, after all...		  Pointer=gdImageCreateTrueColor(w, h)		  		  // get the number of bytes per line		  k=TIFFScanlineSize(Tif)		  nbytes=k-1		  // bytes per pixel		  size=k/w		  // allocate memory.		  raster=New MemoryBlock(k)		  		  j=h-1		  for i=0 to j		    // Read one line into buffer		    TIFFReadScanline(Tif, raster, i, 0)		    for p=0 to nbytes step size		      // get the colour		      r=raster.Byte(p)		      g=raster.Byte(p+1)		      b=raster.Byte(p+2)		      // allocate colour if necessary		      cl=ColorResolve(r, g, b)		      // draw pixel		      SetPixel(p/size, i, cl)		    next		  next		  		  // All done. Nice eh?		  TIFFClose(Tif)		  		  FilePath=FP		  		  // TODO - SaveAsTiff		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub OpenWbmp(FP As String)		  // barfs. Dunno why. But who cares about that format anyway? :-P		  // dda. 2007.02.03		  Declare Function gdImageCreateFromWBMPPtr Lib libgd (DataSize As Integer, Data As Ptr) As Ptr		  		  Dim size As Integer		  Dim Data As MemoryBlock		  Dim f As FolderItem		  Dim bs As BinaryStream		  		  f=GetFolderItem(FP, f.PathTypeShell)		  if not f.Exists Then Return		  		  bs=BinaryStream.Open(f, False)		  if bs=Nil Then Return		  		  size=bs.Length		  Print "Size = "+Format(size, "###,###")		  Data=bs.Read(size)		  bs=Nil		  		  Pointer=gdImageCreateFromWBMPPtr(size, Data)		  		  FilePath=FP		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Polygon(Points() As Integer, colour As Integer)		  Declare Sub gdImagePolygon Lib libgd _		  (im As Ptr, gdPointPtr As Ptr, numPoints As Integer, colour As Integer)		  		  Dim gdPoints As MemoryBlock		  Dim i,j,n As Integer		  		  j=UBound(Points)		  n=(j+1)*4		  gdPoints=New MemoryBlock(n)		  for i=0 to j		    gdPoints.Long(i*4)=Points(i)		  next		  n=(j+1)/2		  		  Call gdImagePolygon(Pointer, gdPoints, n, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Rectangle(x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, colour As Integer)		  Declare Sub gdImageRectangle Lib libgd _		  (im As Ptr, x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, colour As Integer)		  		  Dim xx1, xx2, yy1, yy2 As Integer		  		  if x1>x2 Then		    xx1=x2		    xx2=x1		  else		    xx1=x1		    xx2=x2		  end if		  if y1>y2 Then		    yy1=y2		    yy2=y1		  else		    yy1=y1		    yy2=y2		  end if		  		  		  Call gdImageRectangle(Pointer, xx1, yy1, xx2, yy2, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Red(x As Integer, y As Integer) As Integer		  Declare Function gdImageRed Lib libgd (im As Ptr, cl As Integer) As Integer		  Dim cl As Integer		  		  cl=GetPixel(x,y)		  		  Return gdImageRed(Pointer, cl)		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAlpha(Alpha As Boolean)		  Declare Sub gdImageSaveAlpha Lib libgd _		  (im As Ptr, AlphaState As Integer)		  		  if Alpha Then		    Call gdImageSaveAlpha(Pointer, 1)		  else		    Call gdImageSaveAlpha(Pointer, 0)		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsGd(FilePath As String)		  Declare Sub gdImageGd Lib libgd (im As Ptr, hd As Ptr)		  Declare Function fopen Lib libc (fi As Ptr, rights As Ptr) As Ptr		  Declare Sub fclose Lib libc (fi As Ptr)		  		  Dim hd, LOCAL_FILE, rights As MemoryBlock		  		  LOCAL_FILE = FilePath+ChrB(0)		  		  rights="wb"+ChrB(0)		  hd = fopen(LOCAL_FILE, rights)		  		  gdImageGd(Pointer, hd)		  fclose(hd)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsGd2(FilePath As String)		  Declare Sub gdImageGd2 Lib libgd (im As Ptr, hd As Ptr)		  Declare Function fopen Lib libc (fi As Ptr, rights As Ptr) As Ptr		  Declare Sub fclose Lib libc (fi As Ptr)		  		  Dim hd, LOCAL_FILE, rights As MemoryBlock		  		  LOCAL_FILE = FilePath+ChrB(0)		  		  rights="wb"+ChrB(0)		  hd = fopen(LOCAL_FILE, rights)		  		  gdImageGd2(Pointer, hd)		  fclose(hd)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsGif(FilePath As String)		  Declare Sub gdImageGif Lib libgd (im As Ptr, hd As Ptr)		  Declare Function fopen Lib libc (fi As Ptr, rights As Ptr) As Ptr		  Declare Sub fclose Lib libc (fi As Ptr)		  		  Dim hd, LOCAL_FILE, rights As MemoryBlock		  		  LOCAL_FILE = FilePath+ChrB(0)		  		  rights="wb"+ChrB(0)		  hd = fopen(LOCAL_FILE, rights)		  		  gdImageGif(Pointer, hd)		  fclose(hd)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsJpeg(FilePath As String)		  Declare Sub gdImageJpeg Lib libgd (im As Ptr, hd As Ptr, quality As Integer)		  Declare Function fopen Lib libc (fi As Ptr, rights As Ptr) As Ptr		  Declare Sub fclose Lib libc (fi As Ptr)		  		  Dim hd, LOCAL_FILE, rights As MemoryBlock		  		  LOCAL_FILE = FilePath+ChrB(0)		  rights="wb"+ChrB(0)		  hd = fopen(LOCAL_FILE, rights)		  		  gdImageJpeg(Pointer, hd, -1)		  fclose(hd)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsJpeg(FilePath As String, quality As Integer)		  Declare Sub gdImageJpeg Lib libgd (im As Ptr, hd As Ptr, quality As Integer)		  Declare Function fopen Lib libc (fi As Ptr, rights As Ptr) As Ptr		  		  Dim hd, LOCAL_FILE, rights As MemoryBlock		  		  LOCAL_FILE = FilePath+ChrB(0)		  rights="wb"+ChrB(0)		  hd = fopen(LOCAL_FILE, rights)		  		  gdImageJpeg(Pointer, hd, quality)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsPng(FilePath As String)		  Declare Sub gdImagePng Lib libgd (im As Ptr, hd As Ptr)		  Declare Function fopen Lib libc (fi As Ptr, rights As Ptr) As Ptr		  Declare Sub fclose Lib libc (fi As Ptr)		  		  Dim hd, LOCAL_FILE, rights As MemoryBlock		  		  LOCAL_FILE = FilePath+ChrB(0)		  rights="wb"+ChrB(0)		  hd = fopen(LOCAL_FILE, rights)		  		  gdImagePng(Pointer, hd)		  fclose(hd)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsTiff(fp As String)		  // GD doesn't support TIFF. I do ;-)		  // requires libtiff, see the constant. Set to /usr/local/lib/libtiff.dylib by default. As it should be...		  		  Declare Sub TIFFSetField  Lib libtiff (Tif As Ptr, Tag As Integer, Value As Integer)		  Declare Sub TIFFSetField  Lib libtiff (Tif As Ptr, Tag As Integer, Value As CString)		  Declare Function TIFFOpen Lib libtiff (fname As Ptr, Rights As Ptr) As Ptr		  // int TIFFWriteScanline(TIFF *tif, tdata_t buf, uint32 row, tsample_t sample)		  Declare Function TIFFWriteScanline Lib libtiff _		  (Tif As Ptr, buffer As Ptr, row As Integer, sample As Integer) As Integer		  Declare Function TIFFWriteEncodedStrip Lib libtiff _		  (Tif As Ptr, number As Integer, buffer As Ptr, length As Integer) As Integer		  		  'Declare Function TIFFScanlineSize Lib libtiff (Tif As Ptr) As Integer		  		  Declare Sub TIFFClose Lib libtiff (Tif As Ptr)		  		  Dim size, h, err, nbytes, p, i, j, k, px, py As Integer		  Dim Tif, rights, fname, raster As MemoryBlock		  		  // libtiff provides for an open function.		  // Just pass file path and rights. Nice.		  fname=fp		  rights="wb"+ChrB(0)		  		  Tif=TIFFOpen(fname, rights)		  if Tif = Nil Then		    Print "Tif = Nil"		    Return		  end if		  		  // get the geometry		  TIFFSetField(Tif, TIFFTAG_IMAGEWIDTH,  SX())		  TIFFSetField(Tif, TIFFTAG_IMAGELENGTH, SY())		  TIFFSetField(Tif, TIFFTAG_BITSPERSAMPLE, 8)		  TIFFSetField(Tif, TIFFTAG_ROWSPERSTRIP, SY())		  TIFFSetField(Tif, TIFFTAG_SAMPLESPERPIXEL, 3)		  		  TIFFSetField(Tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW)		  TIFFSetField(Tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)		  TIFFSetField(Tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB)		  		  TIFFSetField(Tif, TIFFTAG_XRESOLUTION, 150.0)		  TIFFSetField(Tif, TIFFTAG_YRESOLUTION, 150.0)		  TIFFSetField(Tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH)		  TIFFSetField(Tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)		  		  TIFFSetField(Tif, TIFFTAG_IMAGEDESCRIPTION, "saved by libgd4rb")		  		  px=SX()		  py=SY()		  k=px*py*3		  raster=New MemoryBlock(k)		  'k=TIFFScanlineSize(Tif)		  		  j=h-1		  for i=0 to j		    for p=0 to nbytes step size		      // get the Pixel into the array		      raster.Byte(p+i*px*3)=Red(p\size, i)		      raster.Byte(p+1+i*px*3)=Green(p\size, i)		      raster.Byte(p+2+i*px*3)=Blue(p\size, i)		    next		    'err = TIFFWriteScanline(Tif, raster, i, 0)		  next		  err = TIFFWriteEncodedStrip(Tif, 0, raster, k)		  		  // All done. Nice eh?		  TIFFClose(Tif)		  		  FilePath=FP		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsWbmp(FilePath As String)		  Declare Sub gdImageWBMP Lib libgd (im As Ptr, hd As Ptr)		  Declare Function fopen Lib libc (fi As Ptr, rights As Ptr) As Ptr		  Declare Sub fclose Lib libc (fi As Ptr)		  		  Dim hd, LOCAL_FILE, rights As MemoryBlock		  		  LOCAL_FILE = FilePath+ChrB(0)		  rights="wb"+ChrB(0)		  hd = fopen(LOCAL_FILE, rights)		  		  gdImageWBMP(Pointer, hd)		  fclose(hd)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetAntiAliased(colour As Integer)		  Declare Sub gdImageSetAntiAliased Lib libgd _		  (im As Ptr, colour As Integer)		  		  Call gdImageSetAntiAliased(Pointer, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetAntiAliasedDontBlend(colour As Integer)		  Declare Sub gdImageSetAntiAliasedDontBlend Lib libgd _		  (im As Ptr, colour As Integer)		  		  Call gdImageSetAntiAliasedDontBlend(Pointer, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetBrush(brush As gdImage)		  Declare Sub gdImageSetBrush Lib libgd _		  (im As Ptr, brush As Ptr)		  		  Call gdImageSetBrush(Pointer, brush.Pointer)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetClip(x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer)		  Declare Sub gdImageSetClip Lib libgd _		  (im As Ptr, x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer)		  		  Dim xx1, xx2, yy1, yy2 As Integer		  		  if x1>x2 Then		    xx1=x2		    xx2=x1		  else		    xx1=x1		    xx2=x2		  end if		  if y1>y2 Then		    yy1=y2		    yy2=y1		  else		    yy1=y1		    yy2=y2		  end if		  		  		  Call gdImageSetClip(Pointer, xx1, yy1, xx2, yy2)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetPixel(x As Integer, y As Integer, colour As Integer)		  Declare Sub gdImageSetPixel Lib libgd _		  (im As Ptr, x As Integer, y As Integer, colour As Integer)		  		  Call gdImageSetPixel(Pointer, x, y, colour)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetStyle(Style() As Integer)		  Declare Sub gdImageSetStyle Lib libgd _		  (im As Ptr, stylePtr As Ptr, numPoints As Integer)		  		  Dim gdPoints As MemoryBlock		  Dim i,j,n As Integer		  		  j=UBound(Style)		  n=(j+1)*4		  gdPoints=New MemoryBlock(n)		  for i=0 to j		    gdPoints.Long(i*4)=Style(i)		  next		  n=(j+1)/2		  		  Call gdImageSetStyle(Pointer, gdPoints, n)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetThickness(thickness As Integer)		  Declare Sub gdImageSetThickness Lib libgd _		  (im As Ptr, thickness As Integer)		  		  Call gdImageSetThickness(Pointer, thickness)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetTile(tile As gdImage)		  Declare Sub gdImageSetTile Lib libgd _		  (im As Ptr, tile As Ptr)		  		  Call gdImageSetTile(Pointer, tile.Pointer)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ShellPath() As String		  Return FilePath		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function SX() As Integer		  Return Pointer.Long(4)		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function SY() As Integer		  Return Pointer.Long(8)		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function TrueColor() As Boolean		  Declare Function gdImageTrueColor Lib libgd _		  (im As Ptr) As Integer		  		  'Return (Pointer.Long(80)<>0)		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub UseFontConfig(fontconfigflag As Boolean)		  Declare Sub gdFTUseFontConfig Lib libgd _		  (fontconfigflag As Integer)		  		  if fontconfigflag Then		    Call gdFTUseFontConfig(1)		  else		    Call gdFTUseFontConfig(0)		  End if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Width() As Integer		  Return SX()		  		End Function	#tag EndMethod	#tag Note, Name = gdImage struct		typedef struct {		  /* Palette-based image pixels */		0000  unsigned char ** pixels;		0004  int sx;		0008  int sy;		  /* These are valid in palette images only. See also		  /* 'alpha', which appears later in the structure to		    preserve binary backwards compatibility */		000C  int colorsTotal;		0010  int red[gdMaxColors];		0014  int green[gdMaxColors];		0018  int blue[gdMaxColors]; 		001C  int open[gdMaxColors];		  /* For backwards compatibility, this is set to the		    first palette entry with 100% transparency,		    and is also set and reset by the 		    gdImageColorTransparent function. Newer		    applications can allocate palette entries		    with any desired level of transparency; however,		    bear in mind that many viewers, notably		    many web browsers, fail to implement		    full alpha channel for PNG and provide		    support for full opacity or transparency only. */		0020  int transparent;		0024  int *polyInts;		0028  int polyAllocated;		002C  struct gdImageStruct *brush;		0030  struct gdImageStruct *tile;  		0034  int brushColorMap[gdMaxColors];		0038  int tileColorMap[gdMaxColors];		003C  int styleLength;		0040  int stylePos;		0044  int *style;		0048  int interlace;		  /* New in 2.0: alpha channel for palettes. Note that only		    Macintosh Internet Explorer and (possibly) Netscape 6		    really support multiple levels of transparency in		    palettes, to my knowledge, as of 2/15/01. Most		    common browsers will display 100% opaque and		    100% transparent correctly, and do something 		    unpredictable and/or undesirable for levels		    in between. TBB */		004C  int alpha[gdMaxColors]; 		  /* Truecolor flag and pixels. New 2.0 fields appear here at the		    end to minimize breakage of existing object code. */		0050  int trueColor;		0054  int ** tpixels;		  /* Should alpha channel be copied, or applied, each time a		    pixel is drawn? This applies to truecolor images only.		    No attempt is made to alpha-blend in palette images,		    even if semitransparent palette entries exist. 		    To do that, build your image as a truecolor image,		    then quantize down to 8 bits. */		0058  int alphaBlendingFlag;		  /* Should the alpha channel of the image be saved? This affects		    PNG at the moment; other future formats may also		    have that capability. JPEG doesn't. */		005C  int saveAlphaFlag;		} gdImage;							#tag EndNote	#tag Property, Flags = &h25		Private FilePath As String	#tag EndProperty	#tag Property, Flags = &h1		Protected LastError As Integer	#tag EndProperty	#tag Property, Flags = &h1		Protected Pointer As MemoryBlock	#tag EndProperty	#tag Constant, Name = COMPRESSION_ADOBE_DEFLATE, Type = Integer, Dynamic = False, Default = \"8", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_CCITTFAX3, Type = Integer, Dynamic = False, Default = \"3", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_CCITTFAX4, Type = Integer, Dynamic = False, Default = \"4", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_CCITTRLE, Type = Integer, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_CCITTRLEW, Type = Integer, Dynamic = False, Default = \"32771", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_CCITT_T4, Type = Integer, Dynamic = False, Default = \"4", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_CCITT_T6, Type = Integer, Dynamic = False, Default = \"4", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_DCS, Type = Integer, Dynamic = False, Default = \"32947", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_DEFLATE, Type = Integer, Dynamic = False, Default = \"32946", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_IT8BL, Type = Integer, Dynamic = False, Default = \"32898", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_IT8CTPAD, Type = Integer, Dynamic = False, Default = \"32895", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_IT8LW, Type = Integer, Dynamic = False, Default = \"32896", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_IT8MP, Type = Integer, Dynamic = False, Default = \"32897", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_JBIG, Type = Integer, Dynamic = False, Default = \"34661", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_JP2000, Type = Integer, Dynamic = False, Default = \"34712", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_JPEG, Type = Integer, Dynamic = False, Default = \"7", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_LZW, Type = Integer, Dynamic = False, Default = \"5", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_NEXT, Type = Integer, Dynamic = False, Default = \"32766", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_NONE, Type = Integer, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_OJPEG, Type = Integer, Dynamic = False, Default = \"6", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_PACKBITS, Type = Integer, Dynamic = False, Default = \"32773", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_PIXARFILM, Type = Integer, Dynamic = False, Default = \"32908", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_PIXARLOG, Type = Integer, Dynamic = False, Default = \"32909", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_SGILOG, Type = Integer, Dynamic = False, Default = \"34676", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_SGILOG24, Type = Integer, Dynamic = False, Default = \"34677", Scope = Public	#tag EndConstant	#tag Constant, Name = COMPRESSION_THUNDERSCAN, Type = Integer, Dynamic = False, Default = \"32809", Scope = Public	#tag EndConstant	#tag Constant, Name = FILLORDER_LSB2MSB, Type = Integer, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag Constant, Name = FILLORDER_MSB2LSB, Type = Integer, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = kPointerInvalid, Type = Double, Dynamic = False, Default = \"-1", Scope = Protected	#tag EndConstant	#tag Constant, Name = libc, Type = String, Dynamic = False, Default = \"/usr/lib/libc.dylib", Scope = Public	#tag EndConstant	#tag Constant, Name = libgd, Type = String, Dynamic = False, Default = \"/sw/lib/libgd.dylib", Scope = Public	#tag EndConstant	#tag Constant, Name = libgd1, Type = String, Dynamic = False, Default = \"/usr/local/lib/libgd.dylib", Scope = Public	#tag EndConstant	#tag Constant, Name = libgd2, Type = String, Dynamic = False, Default = \"@executable_path/lib/libgd.dylib", Scope = Public	#tag EndConstant	#tag Constant, Name = libtiff, Type = String, Dynamic = False, Default = \"/usr/local/lib/libtiff.dylib", Scope = Public	#tag EndConstant	#tag Constant, Name = libtiff1, Type = String, Dynamic = False, Default = \"@executable_path/lib/libtiff.dylib", Scope = Public	#tag EndConstant	#tag Constant, Name = PHOTOMETRIC_CIELAB, Type = Integer, Dynamic = False, Default = \"8", Scope = Public	#tag EndConstant	#tag Constant, Name = PHOTOMETRIC_ITULAB, Type = Integer, Dynamic = False, Default = \"10", Scope = Public	#tag EndConstant	#tag Constant, Name = PHOTOMETRIC_LOGL, Type = Integer, Dynamic = False, Default = \"32844", Scope = Public	#tag EndConstant	#tag Constant, Name = PHOTOMETRIC_LOGLUV, Type = Integer, Dynamic = False, Default = \"32845", Scope = Public	#tag EndConstant	#tag Constant, Name = PHOTOMETRIC_MASK, Type = Integer, Dynamic = False, Default = \"4", Scope = Public	#tag EndConstant	#tag Constant, Name = PHOTOMETRIC_MINISBLACK, Type = Integer, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = PHOTOMETRIC_MINISWHITE, Type = Integer, Dynamic = False, Default = \"0", Scope = Public	#tag EndConstant	#tag Constant, Name = PHOTOMETRIC_PALETTE, Type = Integer, Dynamic = False, Default = \"3", Scope = Public	#tag EndConstant	#tag Constant, Name = PHOTOMETRIC_RGB, Type = Integer, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag Constant, Name = PHOTOMETRIC_SEPARATED, Type = Integer, Dynamic = False, Default = \"5", Scope = Public	#tag EndConstant	#tag Constant, Name = PHOTOMETRIC_YCBCR, Type = Integer, Dynamic = False, Default = \"6", Scope = Public	#tag EndConstant	#tag Constant, Name = PLANARCONFIG_CONTIG, Type = Integer, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = PLANARCONFIG_SEPARATE, Type = Integer, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag Constant, Name = RESUNIT_CENTIMETER, Type = Integer, Dynamic = False, Default = \"3", Scope = Public	#tag EndConstant	#tag Constant, Name = RESUNIT_INCH, Type = Integer, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag Constant, Name = RESUNIT_NONE, Type = Integer, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_ARTIST, Type = Integer, Dynamic = False, Default = \"315", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_BITSPERSAMPLE, Type = Integer, Dynamic = False, Default = \"258", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_COMPRESSION, Type = Integer, Dynamic = False, Default = \"259", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_COPYRIGHT, Type = Integer, Dynamic = False, Default = \"33432", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_DATETIME, Type = Integer, Dynamic = False, Default = \"306", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_DOCUMENTNAME, Type = Integer, Dynamic = False, Default = \"269", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_FILLORDER, Type = Integer, Dynamic = False, Default = \"266", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_IMAGEDESCRIPTION, Type = Integer, Dynamic = False, Default = \"270", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_IMAGELENGTH, Type = Integer, Dynamic = False, Default = \"257", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_IMAGEWIDTH, Type = Integer, Dynamic = False, Default = \"256", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_PHOTOMETRIC, Type = Integer, Dynamic = False, Default = \"262", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_PLANARCONFIG, Type = Integer, Dynamic = False, Default = \"284", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_RESOLUTIONUNIT, Type = Integer, Dynamic = False, Default = \"296", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_ROWSPERSTRIP, Type = Integer, Dynamic = False, Default = \"278", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_SAMPLESPERPIXEL, Type = Integer, Dynamic = False, Default = \"277", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_XRESOLUTION, Type = Integer, Dynamic = False, Default = \"282", Scope = Public	#tag EndConstant	#tag Constant, Name = TIFFTAG_YRESOLUTION, Type = Integer, Dynamic = False, Default = \"283", Scope = Public	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass